
\documentclass[11pt,letterpaper]{article}
\usepackage{amssymb,amsmath}
\usepackage{mathrsfs}
\usepackage{epsfig}
\usepackage{anysize}
\usepackage{verbatim}
\usepackage{dirtytalk}  
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyvrb}
%\input{macrosal}
\title{Solucionador de Nonogramas utilizando algoritmos genéticos}
\author{Víctor Zamora Gutiérrez}
\date{}
\begin{document}
\maketitle
\thispagestyle{empty}
\section{Introducción}
Los nonogramas son rompecabezas en los que se tiene una cuadrícula rectangular en la que cada cuadro tiene un color de dos disponibles: blanco y negro. Las reglas son sencillas: se empieza con un tablero completamente blanco. Cada fila y cada columna tienen una lista de números llamada \say{restricciones} que nos dicen cómo debe ser llenada esa fila o columna. El objetivo del juego es llenar el tablero de manera que las restricciones de las filas y columnas se cumplan.

Las restricciones nos dictan \say{segmentos} que deben ser llenados de la fila o columna. Por ejemplo, si tenemos la restricción $<2>$, entonces deben haber dos cuadros negros consecutivos en cualquier parte de esa fila o columna. Si en cambio, tenemos la lista de restricciones $<2, 3, 5>$, entonces debemos tener un segmeno de dos cuadros negros seguido de un segmento de 3 cuadros negros seguido de un segmento de 5 cuadros negros. Los segmentos negros deben estar separados por segmentos blancos (de tamaño arbitrario). Por ejemplo, en una fila de tamaño 4 con restricciones $<1, 1>$, las siguientes soluciones son válidas:
\begin{center}
\begin{BVerbatim}    
  |#|_|#|_|
  |#|_|_|#|
  |_|#|#|_|
  |_|#|_|#|
  |_|_|#|#|
\end{BVerbatim}
\end{center}

Estas son además, las \textbf{únicas} soluciones válidas.

Aunque algunos de estos rompecabezas pueden resolverse de manera sencilla por métodos deterministas, en general, resolver un nonograma es un problema NP-Completo \cite{ueda1996np}. En este trabajo, vamos a intentar resolver nonogramas utilizando algoritmos genéticos.

\section{Algoritmos genéticos}
Los algoritmos genéticos están basados en la selección natural. Empezamos con una población de instancias de solución aleatorias. En cada iteración del algoritmo, \say{reproducimos} a los individuos \say{más aptos} de dicha generación, generando así instancias hijas con probabilidad alta de ser aptas, incluso pudiendo superar a sus padres. La idea del algoritmo es mejorar poco a poco la calidad de la población hasta llegar a instancias \say{cercanas} a la solución óptima.

Para que el algoritmo no se quede atorado cerca de algún mínimo local, es decir que de verdad pueda encontrar la solución óptima, tenemos un factor de mutación que se aplica cada vez que nace un hijo. El factor de mutación, con cierta probabilidad, altera aleatoriamente una porción de una instancia. En general, la mutación nos lleva a resultados peores, pero esto no es necesariamente malo.

La población que pasa de una generación a otra no está compuesta solamente por individuos \say{nuevos}. En cada generación, pasan automáticamente la mejor instancia vista (para que nuestras soluciones no puedan empeorar con el tiempo) y una instancia \textit{alien} o aleatoria.

En el caso de los nonogramas, el algoritmo genético es bastante sencillo. Como tenemos matrices rectangulares, la reproducción de dos nonogramas consiste simplemente en combinar la mitad de una matriz con la mitad de la otra. La mutación consiste en cambiar un número arbitrario de valores de la matriz (si el valor es blanco se cambia a negro y viceversa).

\subsection{Función de aptitud}
En general, la función de aptitud es una parte complicada de los algoritos genéticos. Determinar qué tan cerca está de la solución una de nuestras instancias normalmente es tan difícil como resolver el problema mismo (y si pudiéramos hacer esto en tiempo polinomial, no habría necesidad de utilizar algoritmos genéticos desde un principio).

Para la función de aptitud, consideraremos que vale 1 en una solución perfecta y que vale 0 si la instancia está al mayor número de pasos de distancia posible de la solución óptima. Dado que nuestro problema es NP-Completo, calcular la distancia entre una solución y la óptima es en sí un problema NP-Completo, por lo que hay que utilizar heurísticas para calcular la aptitud de un individuo.

En el caso de este problema en particular, consideramos la distancia de nuestro nonograma al óptimo como el máximo número de errores. Este número tampoco es calculable en tiempo polinomial. Sin embargo, podemos hacer una estimación como sigue:

Para cada fila o columna, sacamos su \textit{lista de colores}. La \textbf{lista de colores} de una fila o columna está definida como la lista que representa los segmentos negros de esa fila o columna. Es decir, si una fila de tamaño 5 está toda de negro, su lista de colores es $<5>$. Si tiene un cuadro negro seguido de dos blancos seguidos de dos negros, su lista de colores es $<1, 2>$. Esto se muestra a continuación:

\textbf{Listas de colores para una fila de tamaño 5}:
\begin{center}
\begin{BVerbatim}    
  |#|_|#|_|#|   Lista: <1, 1, 1>
  |#|#|#|#|#|   Lista: <5>
  |#|_|_|#|#|   Lista: <1, 2>
  |_|#|_|#|#|   Lista: <1, 2>
\end{BVerbatim}
\end{center}

Nótese que dos configuraciones distintas de una fila o columna pueden tener la misma lista de colores.

Una vez teniendo la lista de colores, se saca la distancia entre esta y la lista de restricciones. Para esto, el algoritmo consiste en obtener el número de pasos que toma llegar de la primera a la segunda, donde un paso es restarle a un número o sumarle a un número. Este algoritmo toma tiempo cuadrático en una implementación ingenua: básicamente contamos el número de pasos que toma transformar el último elemento de la lista de colores al primero de la lista de restricciones (y sus adyacentes a sus correspodientes), el último al segundo, etc.

\section{Resultados}
Con mi implementación en \texttt{Java}, logré resolver nonogramas de tamaños variables, con el más grande resuelto siendo uno de 10x10 en cuestión de unos cuantos segundos. Dado que el tamaño de las soluciones crece de manera exponencial, habrá que hacer unas cuantas modificaciones al proyecto para solucionar nonogramas más grandes.

Mi meta a futuro es resolver Nonogramas de tamaño 30x30. 

\section{Uso del programa}
Para compilar: \texttt{ant}

Para obtener la documentación: \texttt{ant doc}

Para correr las pruebas unitarias: \texttt{ant test}

Para correr el programa (una vez compilado): \texttt{java -jar nonograma.jar}

Para limpiar la carpeta de trabajo: \texttt{ant clean}

\nocite{*}
\bibliographystyle{plain}
\bibliography{nonograma}
\end{document}
 
 
